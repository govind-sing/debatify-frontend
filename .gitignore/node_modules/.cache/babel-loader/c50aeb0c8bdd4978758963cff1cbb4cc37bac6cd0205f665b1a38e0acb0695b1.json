{"ast":null,"code":"const express = require(\"express\");\nconst router = express.Router();\nconst User = require(\"../models/User\");\nconst bcrypt = require(\"bcryptjs\");\nconst jwt = require(\"jsonwebtoken\");\nconst nodemailer = require(\"nodemailer\");\nconst crypto = require(\"crypto\");\nconst OTPStore = new Map(); // In-memory OTP storage (Use DB for production)\n\n// Nodemailer Transporter Setup (Gmail SMTP)\nconst transporter = nodemailer.createTransport({\n  service: \"gmail\",\n  auth: {\n    user: \"your-email@gmail.com\",\n    // Replace with your email\n    pass: \"your-app-password\" // Use App Password, not email password\n  }\n});\n\n// =================== SIGNUP with Email Verification ===================\nrouter.post(\"/signup\", async (req, res) => {\n  try {\n    const {\n      username,\n      email,\n      password\n    } = req.body;\n    const existingUser = await User.findOne({\n      email\n    });\n    if (existingUser) return res.status(400).json({\n      message: \"Email already registered\"\n    });\n    const hashedPassword = await bcrypt.hash(password, 10);\n    const newUser = new User({\n      username,\n      email,\n      password: hashedPassword\n    });\n    await newUser.save();\n\n    // Generate OTP\n    const otp = Math.floor(100000 + Math.random() * 900000).toString();\n    OTPStore.set(email, {\n      otp,\n      expires: Date.now() + 10 * 60 * 1000\n    }); // Expires in 10 min\n\n    // Send verification email\n    await transporter.sendMail({\n      from: \"your-email@gmail.com\",\n      to: email,\n      subject: \"Verify your Email\",\n      html: `<h3>Your OTP for email verification: ${otp}</h3>`\n    });\n    res.status(201).json({\n      message: \"Signup successful. Verify your email using OTP sent.\"\n    });\n  } catch (err) {\n    console.error(\"Signup Error:\", err);\n    res.status(500).json({\n      message: \"Server error\"\n    });\n  }\n});\n\n// =================== Verify OTP (For Email Verification) ===================\nrouter.post(\"/verify-otp\", async (req, res) => {\n  const {\n    email,\n    otp\n  } = req.body;\n  const storedOTP = OTPStore.get(email);\n  if (!storedOTP || storedOTP.otp !== otp) return res.status(400).json({\n    message: \"Invalid or expired OTP\"\n  });\n  OTPStore.delete(email); // OTP used, remove it\n  await User.findOneAndUpdate({\n    email\n  }, {\n    isVerified: true\n  });\n  res.json({\n    message: \"Email verified successfully\"\n  });\n});\n\n// =================== LOGIN ===================\nrouter.post(\"/login\", async (req, res) => {\n  try {\n    const {\n      email,\n      password\n    } = req.body;\n    const user = await User.findOne({\n      email\n    });\n    if (!user) return res.status(404).json({\n      message: \"User not found\"\n    });\n\n    // Optional: check if user is verified\n    // if (!user.isVerified) return res.status(400).json({ message: \"Please verify your email first\" });\n\n    const isMatch = await bcrypt.compare(password, user.password);\n    if (!isMatch) return res.status(400).json({\n      message: \"Invalid credentials\"\n    });\n    const token = jwt.sign({\n      userId: user._id\n    }, \"your_jwt_secret\", {\n      expiresIn: \"7d\"\n    });\n    res.json({\n      token,\n      message: \"Login successful\"\n    });\n  } catch (err) {\n    console.error(\"Login Error:\", err);\n    res.status(500).json({\n      message: \"Server error\"\n    });\n  }\n});\n\n// =================== Forgot Password - Send OTP ===================\nrouter.post(\"/forgot-password\", async (req, res) => {\n  try {\n    const {\n      email\n    } = req.body;\n    const user = await User.findOne({\n      email\n    });\n    if (!user) return res.status(404).json({\n      message: \"User not found\"\n    });\n\n    // Generate OTP\n    const otp = Math.floor(100000 + Math.random() * 900000).toString();\n    OTPStore.set(email, {\n      otp,\n      expires: Date.now() + 10 * 60 * 1000\n    });\n    await transporter.sendMail({\n      from: \"your-email@gmail.com\",\n      to: email,\n      subject: \"Password Reset OTP\",\n      html: `<h3>Your OTP for password reset: ${otp}</h3>`\n    });\n    res.json({\n      message: \"OTP sent to your email\"\n    });\n  } catch (err) {\n    console.error(\"Forgot Password Error:\", err);\n    res.status(500).json({\n      message: \"Server error\"\n    });\n  }\n});\n\n// =================== Reset Password using OTP ===================\nrouter.post(\"/reset-password\", async (req, res) => {\n  try {\n    const {\n      email,\n      otp,\n      newPassword\n    } = req.body;\n    const storedOTP = OTPStore.get(email);\n    if (!storedOTP || storedOTP.otp !== otp) return res.status(400).json({\n      message: \"Invalid or expired OTP\"\n    });\n    const hashedPassword = await bcrypt.hash(newPassword, 10);\n    await User.findOneAndUpdate({\n      email\n    }, {\n      password: hashedPassword\n    });\n    OTPStore.delete(email); // Clear OTP after use\n    res.json({\n      message: \"Password reset successfully\"\n    });\n  } catch (err) {\n    console.error(\"Reset Password Error:\", err);\n    res.status(500).json({\n      message: \"Server error\"\n    });\n  }\n});\nmodule.exports = router;","map":{"version":3,"names":["express","require","router","Router","User","bcrypt","jwt","nodemailer","crypto","OTPStore","Map","transporter","createTransport","service","auth","user","pass","post","req","res","username","email","password","body","existingUser","findOne","status","json","message","hashedPassword","hash","newUser","save","otp","Math","floor","random","toString","set","expires","Date","now","sendMail","from","to","subject","html","err","console","error","storedOTP","get","delete","findOneAndUpdate","isVerified","isMatch","compare","token","sign","userId","_id","expiresIn","newPassword","module","exports"],"sources":["/Users/govindsinghtanwar/coding/Projects/debatify/frontend/src/pages/CreateDebate.js"],"sourcesContent":["const express = require(\"express\");\nconst router = express.Router();\nconst User = require(\"../models/User\");\nconst bcrypt = require(\"bcryptjs\");\nconst jwt = require(\"jsonwebtoken\");\nconst nodemailer = require(\"nodemailer\");\nconst crypto = require(\"crypto\");\n\nconst OTPStore = new Map(); // In-memory OTP storage (Use DB for production)\n\n// Nodemailer Transporter Setup (Gmail SMTP)\nconst transporter = nodemailer.createTransport({\n  service: \"gmail\",\n  auth: {\n    user: \"your-email@gmail.com\",  // Replace with your email\n    pass: \"your-app-password\",     // Use App Password, not email password\n  },\n});\n\n// =================== SIGNUP with Email Verification ===================\nrouter.post(\"/signup\", async (req, res) => {\n  try {\n    const { username, email, password } = req.body;\n    const existingUser = await User.findOne({ email });\n    if (existingUser) return res.status(400).json({ message: \"Email already registered\" });\n\n    const hashedPassword = await bcrypt.hash(password, 10);\n    const newUser = new User({ username, email, password: hashedPassword });\n    await newUser.save();\n\n    // Generate OTP\n    const otp = Math.floor(100000 + Math.random() * 900000).toString();\n    OTPStore.set(email, { otp, expires: Date.now() + 10 * 60 * 1000 }); // Expires in 10 min\n\n    // Send verification email\n    await transporter.sendMail({\n      from: \"your-email@gmail.com\",\n      to: email,\n      subject: \"Verify your Email\",\n      html: `<h3>Your OTP for email verification: ${otp}</h3>`,\n    });\n\n    res.status(201).json({ message: \"Signup successful. Verify your email using OTP sent.\" });\n  } catch (err) {\n    console.error(\"Signup Error:\", err);\n    res.status(500).json({ message: \"Server error\" });\n  }\n});\n\n// =================== Verify OTP (For Email Verification) ===================\nrouter.post(\"/verify-otp\", async (req, res) => {\n  const { email, otp } = req.body;\n  const storedOTP = OTPStore.get(email);\n\n  if (!storedOTP || storedOTP.otp !== otp) return res.status(400).json({ message: \"Invalid or expired OTP\" });\n\n  OTPStore.delete(email); // OTP used, remove it\n  await User.findOneAndUpdate({ email }, { isVerified: true });\n  res.json({ message: \"Email verified successfully\" });\n});\n\n// =================== LOGIN ===================\nrouter.post(\"/login\", async (req, res) => {\n  try {\n    const { email, password } = req.body;\n    const user = await User.findOne({ email });\n    if (!user) return res.status(404).json({ message: \"User not found\" });\n\n    // Optional: check if user is verified\n    // if (!user.isVerified) return res.status(400).json({ message: \"Please verify your email first\" });\n\n    const isMatch = await bcrypt.compare(password, user.password);\n    if (!isMatch) return res.status(400).json({ message: \"Invalid credentials\" });\n\n    const token = jwt.sign({ userId: user._id }, \"your_jwt_secret\", { expiresIn: \"7d\" });\n    res.json({ token, message: \"Login successful\" });\n  } catch (err) {\n    console.error(\"Login Error:\", err);\n    res.status(500).json({ message: \"Server error\" });\n  }\n});\n\n// =================== Forgot Password - Send OTP ===================\nrouter.post(\"/forgot-password\", async (req, res) => {\n  try {\n    const { email } = req.body;\n    const user = await User.findOne({ email });\n    if (!user) return res.status(404).json({ message: \"User not found\" });\n\n    // Generate OTP\n    const otp = Math.floor(100000 + Math.random() * 900000).toString();\n    OTPStore.set(email, { otp, expires: Date.now() + 10 * 60 * 1000 });\n\n    await transporter.sendMail({\n      from: \"your-email@gmail.com\",\n      to: email,\n      subject: \"Password Reset OTP\",\n      html: `<h3>Your OTP for password reset: ${otp}</h3>`,\n    });\n\n    res.json({ message: \"OTP sent to your email\" });\n  } catch (err) {\n    console.error(\"Forgot Password Error:\", err);\n    res.status(500).json({ message: \"Server error\" });\n  }\n});\n\n// =================== Reset Password using OTP ===================\nrouter.post(\"/reset-password\", async (req, res) => {\n  try {\n    const { email, otp, newPassword } = req.body;\n    const storedOTP = OTPStore.get(email);\n\n    if (!storedOTP || storedOTP.otp !== otp) return res.status(400).json({ message: \"Invalid or expired OTP\" });\n\n    const hashedPassword = await bcrypt.hash(newPassword, 10);\n    await User.findOneAndUpdate({ email }, { password: hashedPassword });\n\n    OTPStore.delete(email); // Clear OTP after use\n    res.json({ message: \"Password reset successfully\" });\n  } catch (err) {\n    console.error(\"Reset Password Error:\", err);\n    res.status(500).json({ message: \"Server error\" });\n  }\n});\n\nmodule.exports = router;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}